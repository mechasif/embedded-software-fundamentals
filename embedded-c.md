# Modern Embedded Systems Programming by Miro Samek

## L1 -> How Computers Counts:

- ARM Cortex-M processors have 16 registers.
  - R0 to R15
  - R15 is also known as PC (Program Counter)
  - All these registers hold 32-bit numbers
 
```c
int main(){
  int counter = 0;
  ++counter; //"++" is called pre-increment
  return 0;
}
```
- Disassembly view: Shows the machine instruction generated by the program

  ![image](https://github.com/user-attachments/assets/0f8a9c80-7c35-43fc-9b47-8972e7ccd05a)

- 4 bits, called a "nibble" -> Map directly to hex digits

- Most of the ARM Cortex instructions occupy 2 bytes in memory

- 0x -> is the C language convention for encoding hex numbers

  ![image](https://github.com/user-attachments/assets/99976946-197c-4d83-a9f5-47c43df594a7)

- 0x7FFFFFFF is the largest possible value a 32-bit signed integer can represent
  - If incremented by 1, then "overflow"
  - become the smallest negative with 32-bits
 
- Signed numbers use 2s Compliment representation
 
  ![image](https://github.com/user-attachments/assets/81dc291a-c3a1-4b84-9772-4def131fa115)

- Machine instruction can manipulate the registers directly, typically in just one clock cycle

## L2 -> How to change the flow of control through code:

- CMP: Compare instruction

- APSR -> Application Program Status Register

- All modern processors, including the ARM Cortex-M, use an instruction pipeline to increase the throughput
  	- Pipeline is like an assembly line, in which the processor works on multiple instructions at various stages of completion
  	- This increases the number of instructions that can be processed in a given time
  	- Each instruction is split into a sequence of independent steps, such as fetch from memory, decode, and execute, whereas each of these steps takes one clock cycle to complete
  	- The pipeline works at full capacity when the instructions are executed in order
  	- But when a Branch instruction (loop in the program) disrupts this ordering, the pipeline needs to discard the partially processed instructions and re-start at the new instruction

    	```c
      int main(){
          int counter = 0;
          while(counter < 21){
          ++counter;
          }
          return 0;
      }
      ```
   
    - This means that the pipeline stalls for a few cycles

      ![image](https://github.com/user-attachments/assets/6396ac6d-ee8b-4fcf-9102-fd0ef03d6954)

- To speed things up, you can unroll some loops either entirely or by as much as you need

  	```c
    int main(){
        int counter = 0;
        while(counter < 20){
        ++counter;
        ++counter;
        }
        ++counter;
   
        return 0;
    }
    ```
- Use "Flow of Control" to make decisions at runtime

  ![image](https://github.com/user-attachments/assets/3577b27d-44ca-4400-a33f-29fa961c07f3)

- & -> The ampersand -> bitwise and operator


## L3 -> Variables & Pointers: 

- LDR.N (Instruction) -> Load from a memory to a register
- ADDS (Instruction) -> Increment the register by 1
- STR (Instruction) -> Stores the value of the, e.g., R0 register to the memory pointed to by the e.g., R1 register
- RISC -> Reduced Instruction Set Computer
  - Where memory can only be read by the special "load" instruction, all data manipulation must happen in the registers. Finally, the special "store" instructions can store the modified register values in the memory.
- This is in contrast to the Complex Instruction Set Computer (CISC) architecture, such as the venerable x86 inside the personal computer, where some of the operands for complex instruction don't need to be in the registers and can still be in memory.
- In the C language, the addresses can be stored inside variables called "pointers"
- The C language has a mechanism to enforce a type by using type casting,
    
    ```c
    int *p_int;
    p_int = (int *)0x20000002U;
    ```
    
- You perform such type casting by placing the name of the type in parentheses in front of the cast expression (int *)
    ```c
    p_int = (int *)0x20000002U;
    *p_int = 0xDEADBEEF;
    ```     

- Due to the intentional misalignment of the fabricated address (0x20000002U), the 0xDEADBEEF value gets written partially over the "counter" variable and partially over the next word in memory
- The Cortex-M4 processors accepted this misaligned address, but Cortex-M0 would have a problem with it

## L4 -> How to control the world outside?:

- GPIO -> General Purpose Input Output
- Clock-gating -> Blocking the clock signal to certain parts of the chip
- In IAR Debugger -> Additional Memory View -> Symbolic Memory
- Bit 5 -> 2^5 -> 32 -> 0x00000020 (Hex)

## L5 -> Preprocessor and the "volatile" keyword in C:

- C preprocessor -> which lets you define any piece of code as a macro
- #-> Pound sign
- Macro -> Simple text substitution
- The preprocessors replace only the macros that are actually used in the code, so the compilers see only the replacement sequence of characters and never the macro names themselves
- The compiler folds any constants computable at compile time and avoids unnecessary computations at runtime
- From the CPU point of view, talking to the outside world is fundamentally very simple and boils down to writing a specific value into a specific address
- On a 32-bit machine, like the ARM processor, the int-type is 32-bit wide, so is the long-type
  - So, "unsigned int" and "unsigned long" are equivalent

- "volatile" qualifier -> Informs the compiler that the object pointed to by the pointer might change spontaneously
- When you declare an object to be "volatile", you are telling the compiler that the object might change even though no statements in the program appear to change it
- Most I/O registers are volatile
- volatile keyword can be placed before the type,
    ```c
    volatile int counter = 0;
    ```
  or, after the type,
    ```c
    int volatile counter = 0;
    ```
      
## L6 -> Bit-wise operators in C:

- Method of setting and clearing the individual bits, without inadvertently disturbing the other bits.

    ```c
    unsigned int a = 0x5A5A5A5A;
          unsigned int b = 0xDEADBEEF;
          unsigned int c;
          c = a | b; //OR [Performed in 1 machine instruction -> ORRS]
          c = a & b; //AND [Performed in 1 machine instruction -> ANDS]
          c = a ^ b; /XOR [Performed in 1 machine instruction -> EORS]
          c = ~ b;   //NOT (Bit inversion) -> 1's Complement [MVNS] (move negative)
          c = b >> 1; //right-shift [LSRS]
          c = b << 3; //left-shift
    ```
    
- The bit-wise "NOT" operator is "unary"
  - Meaning that it acts on just one operand, in which it turns every 1 bit to 0 and 0 to 1

- Right-shift (for unsigned): The right bit-shift operation shifts all the bits in the first operand by the number of places specified in the second operand
  - For the shift by 1, this corresponds to integer division by 2 to the power 1
  - LSRS -> instruction shifts zeros into the most significant bit (MSB) position

- Left-shift: The left bit-shift operation shifts all the bits in the first operand to the left by the number of places specified in the second operand
  - For the shift 3, this corresponds to integer multiplication by 2 to the power 3, which is 8\
  - But you need to be careful because, for a large first operand, some of the most significant bits (MSBs) might "fall off the left edge," which means that the result after the shift no longer fits in the 32-bits
  - LSLS -> Instruction shifts zeros into the least significant bit position

- Signed Right-shift:
    
    ```c
    int x = 1024;
    int y = -1024;
    int z;
    z = x >> 3; [1024/2^3 => 1024/8 => 128]
    z = y >> 3; [(-1024)/2^3 => (-1024)/8 => -128]
    ``` 
          
- Right-shifting of a signed integer shift zeros into the most significant bit (MSB), when the bit is zero before the shift, and ones when the bit is one before the shift\
  - This is called sign-extending of a negative value in the 2's complement representation

- ASRS -> Machine instruction of right-shifting of signed numbers, Arithmetic Right Shift
- LSRS -> Logical Right Shift, for right-shifting of unsigned numbers
    
    ```c
    #define LED_GREEN (1U << 3)
    ```
      
  - This bit-shift expression is a compile-time constant, so there is absolutely no overhead compared to defining LED_GREEN as 0x08
  - But the advantage here is that you immediately see the bit number as the shift displacement
  - For low-order bits, this advancement is perhaps not that impressive, but for high-order bits, say, bit-18, it is not that easy at all to see that this is equivalent to 0x4000


- C language special abbreviation notation for assignments
    
    ```c
    a = a | b is same as, a |= b
    ```
    
- Bit-set idiom, |=
- Bit-clear idiom, &= [However, the Datasheet needs to be checked to confirm the registers have R/W permission]

- BIC -> Machine instruction for Bit Clear

    
## L7 -> Arrays and Pointers Arithmetic:

- Interrupts are a hardware-supported mechanism for a processor to abruptly change the flow of control in your program
- When an interrupt occurs, special hardware in the processor changes the value of the Program Counter (PC) register so that the processor suddenly starts executing a different piece of code called the "Interrupt Service Routine (ISR)"
- If the interrupt happens to come in the middle of the read-modify-write cycle after the main code reads the GPIO register, but before it writes the modified value back, any changes to the GPIO bits made in the ISR will get lost/
    - Because the main code will still use the previous value of the GPIO register before the interrupt happened
 
- Arrays in C are closely related to pointers
- The C compiler treats an array as a pointer

```c
counter[1]
/*can be written as*/
*(counter+1)
```

Example:

```c
#define LED_RED (1U<<1)
#define GPIO_PORTF_DATA_BITS_R ((volatile unsigned long*)0x40025000 //casting

/*using Address Arithmatic*/
*((unsigned long volatile *)(0x40025000+(LED_RED<<2))) = LED_RED; //Address arithmetic

/*same using Array Indexing*/
GPIO_PORTF_DATA_BITS_R[LED_RED] = LED_RED;

/*same using Pointer arithmetic*/
*(GPIO_PORTF_DATA_BITS_R + LED_RED) = LED_RED;

```
- These are the fast and interrupt-safe techniques for manipulating the GPIO bits

## L8 -> Function in C and the call stack:

- DRY principle: Do No Repeat Yourself
- A function in C, aka a procedure, subroutine or sub-program in other programming languages, is a reusable piece of code that can be executed from many different points in a program

Example:
```c
void function_name (void) {//code body} /*Signature of the function*/
```

- BL: Branch machine instruction, changes the value of the program counter (PC)

  -- side effect: to save the address of the next instruction into the Link Register (LR)

- LR: Link Register remember the place in the code to return to after a function completes

- The instruction set of ARM Cortex-M processors, which is called "THUMB2" consists of mostly 2-byte and occasionally 4-byte instructions
- All "THUMB2" instruction must be aligned at an even address

- SP: Stack Pointer register
      - The SP is the hardware implementation of the C call stack mechanism
- A C stack is an area of RAM that can grow or shrink from one end only\
      - The end is called the top of the stack\
      - SP register contains the top address

- In the ARM processors, the stack grows towards the lower addresses (which is up in the memory view) and shrinks towards high addresses (which is down in the memory view)

- The stack is used for two purposes,
      - Holds the local variable of the function called/
      - Stores the return address

- The benefit of using a function prototype is that the compiler can now warn you whenever you forget to provide the right number and type of arguments for every function called


## L9 -> Modules, Recursion, ARM Application Procedure Call Standard (AAPCS):

- Multiple inclusion protection,

```c
/*ifndef: if-not-defined
Idea, this macro is not defined initially,
so the preprocessor will go beyond the #ifndef directive the first time
__FILE_H__ is a naming style called mangled name*/

#ifndef __FILE_H__

/*Next line defines the macro*/
#define __FILE_H__ 

//Code body

/*End of the macro*/
#endif
```

- Therefore, should the header file be included again, the preprocessor will NOT go past the #ifndef directive, and the body of the file will be skipped up to the matching #endif directive


## L10 -> Stack Overflow and Other Pitfalls of Function:

- Heap is the region of RAM for dynamic memory allocation with the standard function\
      -- malloc() - to allocate the memory
      -- free() - to free the memory

- Heap is useful in general-purpose computing but causes more harm than good in embedded programming
      -- So, set the Heap size to "0"

- You cannot assume that any automatic variable has any particular initial value, but instead, you have to explicitly initialize every automatic variable to the value you need.

- Call Stack view: Show all the function calls currently nested on the stack

- BusFault exception is a hardware mechanism implemented in the CPU to handle the situation when the CPU is forced to access nonexistent memory

- The IAR startup code implements the BusFault exception as well as other exceptions, as an endless loop

- Check the stack pointer when you find your program hanging inside a hardware exception

- Stack overflow can fail in some other ways as well. such as only corrupting some data but not running out of memory, which can be much harder to detect and diagnose

- The return type form main() must be "int" because this is required by the C standard

- Function arguments are just like local variables, which you can modify\
      -- The only difference is that arguments are initialized by the caller and local variables must be initialized inside the function\
      -- C passes function arguments by value, meaning that only the argument's value is copied to the internal variable to initialize it, but internally the function uses this copy rather than the original argument\
      -- This means that a function will never change the original argument

- To change the value of arguments, indirection of pointers used as arguments

- Returning pointers from functions,\
      -- Returning a pointer to a local variable is always a bad idea because such pointers will always fall above the stack after the function returns\
      -- All local variables go out of scope when the function returns, so they no longer even exist and can't be accessed\
      -- Remedy, instead of using local variables on the stack, use local variables that are not on the stack\
      -- In C, the "static" keyword is used in front of a local variable and tells the compiler to allocate the variable outside of the stack, so that it outlives any call to the function and therefore can be accessed even after the function returns.


## L11 -> Standard integers (stdint.h) and mixing integer types:

- C built-in integer types:\
      -- int\
      -- unsigned

- The issue is that the C standard does not prescribe their size. For example, 'int' or 'unsigned' can be 32-bit wide on a 32-bit machine, such as ARM, but they can be only 16-bit on a 16-bit or 8-bit on an 8-bit machine such as MSP430 or AVR

- C language also offers,\
      -- short\
      -- unsigned short\
      -- long\
      -- unsigned long\
      -- char\
      -- unsigned char

- The ARM processors have special instructions,\
      -- LDRB and STRB to read and write bytes,\
      -- LDRH and STRH to read and write half-words,\
      -- LDR and STR to read and write whole words

- ARM is the so-called little-endian machine,\
      -- Or, strictly speaking, the ARM core has configurable endianness 

- Virtually all silicon vendors such as Texas Instruments, chose the little-endian configuration

- Little-endian: means that lower-order bytes from a register are placed at lower addresses than higher-order bytes, it is a method of storing multi-byte data where the least significant byte (LSB) is stored at the lowest memory address, and the most significant byte (MSB) is stored at the highest memory address

- Big-endian: does the opposite

- C always automatically promotes any smaller size integers to the built-in 'int' or 'unsigned int' type before performing any computations

- Mixing integers:

```c
uint16_t u16c, u16d;
uint32_t u32e;

int main() {
      u16c = 40000U;
      u16d = 30000U;
      u32e = u16c + u16d;
}
```
- u32e = 70000, will happen in a 32-bit machine like ARM
- But if the code is executed in a machine where the standard 'int' data type is only 16-bit wide, such as MSP430,\
      -- u32e will be 4464\
      -- This happened because, on MSP430, there was no real promotion because the type 'int' is only 16-bit wide\
      -- So, the computation happened in 16-bits, which overflew\
      -- mean, 4464 is the truncated value to 16-bits

- The precision with which the computation is performed does *not* depend on the left-hand side of the assignment

- The solution is to enforce promotion to a 32-bit precision, of at least one of the operands, that way the other implicit conversion rule of the C language will apply\
      -- Which is that the computation is performed at the largest precision of the involved operands\
      -- Specifically, if one of the operands is 32-bit wide, the other will be promoted to 32-bits, and the whole computation will be performed at 32-bit\
      -- So, the solution is to explicitly cast one, or both of the operands to 'uint32_t', as follows,
```c
u32e = (uint32_t)u16c + u16d; /*Truly portable code, no additional CPU cycle needed in 32-bit machine*/
```

- Problems also can arise with changing the signedness of an arithmetic operation,

```c
u16c = 100U;
s32 = 10 - u16c; /*int32_t s32*/
```

- The expected result is s32 = -90 [Run on ARM]
- However, on MSP430, s32 = 65446

- The implicit conversion rule is when you mix signed and unsigned operands, both are promoted to 'unsigned int', and the result is 'unsigned int'
- Subsequently, the result will converted to signed 32-bit, because this is the type of the s32 variable on the left-hand side of the assignment
- However, when the same expression is evaluated on the 16-bit MSP430, the 'unsigned int' is only 16-bit wide and fills up only the lower half of the s32 variable
- The solution is to avoid mixing signed and unsigned, instead, you should explicitly cast the unsigned variable to a signed type

```c
s32 = 10 - (int16_t)u16c;
```

- Example, if(u32e > -1) -> Compiler throws warning\
      -- The -1 value is promoted to 'unsigned int' which is 0xFFFFFFFF, which is the largest value a 32-bit unsigned integer can hold\
      -- Therefore, the comparison will always be false\
      -- The fix is, if((int32_t)u32e > -1) -> Casting to singed integer

- Binary operation on small integers,

```c
u8a = 0xffu;
if(~u8a == 0x00u) /*Compiler will reject this*/
```

- You compare here bitwise 1's complement of a byte with zero
- Something like this could come up, for example, when your byte represents a checksum over some data and you want to make sure that the checksum adds up
- At first glance, with value 0xff in u8a, the comparison should be true, because 1's complement simply inverts all the bits
- But in fact, the comparison will always be false and the whole thing will be eliminated by the compiler
- The compiler knows that the comparison will never be true, because the byte u8a will be promoted 'int', so the MSBs will be zero
- When 1s complement is taken, the MSBs will be all ones, so the result can never be zero
- The remedy, in this case, is specifically revert the promotion to int by casting the inverted value back to a byte

```c
if((uint8_t)(~u8a) == 0x00u)
```

- Side-by-side comparison of 1's complement and 2's complement:

| Feature                        | 1's Complement                                 | 2's Complement                                 |
|--------------------------------|------------------------------------------------|------------------------------------------------|
| Definition                     | Invert all bits                                | Invert all bits and add 1 to the least significant bit |
| Representation of +5           | 0101                                           | 0101                                           |
| Representation of -5           | 1010                                           | 1011                                           |
| Number of zero representations | Two (0000 and 1111)                            | One (0000)                                     |
| Arithmetic simplicity          | Requires end-around carry                      | Simpler arithmetic without special rules       |
| Range for 4-bit numbers        | -7 to +7                                       | -8 to +7                                       |


## L12 -> Structures in C and Cortex Microcontroller Software Interface Standard (CMSIS):

- CMSIS uses structure to access hardware in Cortex-M
- Structures are mechanisms in C to group variables, possibly of *different* types.\
  -- The benefit, they permit a group of related variables to be treated as a unit instead of as separate entities.

- In embedded systems structure also permits to access hardware

```c
struct Point {
  uint16_t x;
  uint8_t y;
} pa, pb;
```

- A structure declaration that is not followed by a list of variables reserves *no storage*, but if the structure is tagged, you can use it later to declare variables
- In C, the "struct" keyword needs to be repeated in front of the structure tag
- This can be solved by "typedef"

```c
typedef struct Point Point;
Point p1, p2; //without struct keyword
```
- Tag names in C occupy a different namespace than typedef names, variable names or function names
- The best approach,

```c
typedef struct{
  uint16_t x;
  uint32_t y;
} Point;

Point p1, p2;
```

- The compiler will honor the order of structure members exactly as typed in the structure declaration
- However, the compiler can and sometimes will insert extra padding bytes into the structure
- The compiler for ARM Cortex-M preferred to waste one byte of memory rather than place a half-word member at an odd address
- In standard C, it is not possible to force the compiler not to waste the byte
- However, most embedded compilers provide some non-standard extension to pack the structure members tightly, without any padding
- Cortex-M processors are truly binary-compatible
  - That means, Cortex-M4 recognizes all instructions for Cortex-M3, which recognizes all instruction for Cortex-M0/M1

-  Alignment of data in memory matters to the processor
-  The compiler prefers to keep the data aligned instead of wasting the CPU cycles to access the misaligned data
-  The variable of structure type is sometimes called instances

-  Pointer to structure: are so frequently used in C that the language offers an alternative operator "arrow (->)" as a quicker way to access a structure member via a pointer
-  A structure for the compiler is nothing else but a bunch of offsets, one for each member, from the beginning of the structure
-  Nested Vector Interrupt Controller (NVIC), which is part of every Cortex-M core

## L13 -> Startup Code Part-1: What is startup code and how does the CPU get from reset to main?

- Startup code: The code that runs even before the main function
- FPU: Floating Point Unit
- SP: Stack Pointer
- BL: Machine Instruction *Branch with Link*, which is a function call
- FPU needs to be initialized early in case any code downstream, such as the main, wants to use it
- BSS: Block Started by Symbol (Old-day assembly name)
- The ARM Cortex-M processor is hardwired such that after reset it copies the bits from address 0 to the SP (Stack Pointer) register, and all the bits except the Least Significant Bit (LSB) from address 0x4 to the PC (Program Counter)
- The Least Significant Bit (LSB) of any value loaded to the PC must be one because this bit indicates the "Thumb Mode" of the processor, which is the only one supported by Cortex-M

- Vector Table: Contains the reset value of the Stack Pointer (SP) and the start address of the PC\
  -- It also contains all the exception and interrupt vectors that your processor can handle

- In the context of Cortex-M, why the address must be an odd number, while the actual code is at an even address?\

  -- The use of an odd address to indicate a "Thumb" state is a convention that simplifies the processor's operation by embedding state information within the address itself\
  -- This design choice helps the processor to quickly determine the execution state and correctly interpret the instruction set without needing additional state flags or registers\

  -- If LSB is 0, ARM state
  -- If LSB is 1, Thumb state

- Thumb Instruction Set: ARM Cortex-M processors use the Thumb instruction set, which is a more compact, 16-bit encoding of the ARM instruction set. This allows for smaller code size and more efficient use of memory

## L14 -> Startup Code Part-2: Replacing the vector table, embedded software build process:

- Cross development: Creating software on one computer (the host) to run on a different one (the target), using tools like cross-compilers and cross-debuggers

- Embedded Build Process:\
  - The source files (main.c, delay.c) are fed to the C-language compiler, which turns them into object files (main.o, delay.o)\
  - All object files from the project, together with any standard or other libraries, as well as the linker script, are fed to the linker, which combines them into the final program
 
- ELF file format: Executable and Linkable file format. AKA, Extensible Linking Format
- Linker must be specific to the target processor
- All object files directly included in the project, such as main.o, delay.o are always linked into the final image
- So, if you ever develop your libraries, remember to make objects small and nimble\
  - Ideally, you should define only one function or one global variable per module\
 
- Linker Error and dump of all the unresolved references still present in the undefined list of the final image\
  - To fix, add an object or a library
  - Sometimes, change the order of libraries
  - Occasionally, specify some libraries more than once in the linking order, to resolve circular inter-dependencies among them


## L15 -> Startup Code Part-3: Vector table initialization, exception handlers, interrupt handlers:

- On the ARM processor the stack grows from high RAM to low RAM
- "extern"\
  -- Introduce a symbol to the compiler, without creating it and allocating storage for it, in C, this can be achieved using a variable declaration that is not a definition\
  -- C provides the special keyword "extern", which is placed in front of the variable definition

  ```c
  extern int newSymbol;
  ```
- C allows to take the address of a function just like, it allows to take the address of a variable
- An address of a function can be obtained in C even when you don't use the ampersand (&) in front of the function name\
  -- This is allowed because a function name not followed by parentheses can't be misconstrued as a call to the function

- The standard way to code an exception handler is to use an endless loop that ties up the CPU when the corresponding exception, such as HardFault, is taken\
  -- This is convenient for debugging because when you break into such code, you find it spinning inside the endless loop\
  -- But this is not recommended for the final product, as it may lead to "freezing" the device until the battery has been pulled out and inserted back in\
  -- This is a classic example of "denial of service", due to incorrectly coded exception handlers\
  -- So, instead of an endless loop the "assert_failed()" function can be called, this provides a common handler for all sorts of errors\
  -- "assert_failed()" is only suitable for situations when you encounter an unrecoverable error and you don't want to continue

- Weak alias: means that if a symbol remains undefined till the end of the linking process, the provided alias will be used
- Fault injection: when a fault is made intentionally

## L16 -> Interrupts Part-1: What are interrupts and how do they work:

- Polling: In which the program keeps checking for a certain condition to occur to do something in response
- Busy_wait polling: It ties up the CPU completely and renders it unavailable for any other work
- Interrupts: Disrupts an ongoing activity and forces you to start doing something else in response to the interrupt
- SysTick: System Timer
- Preemption: When the interrupt line is high, the special CPU hardware forces the CPU to execute the interrupt entry instruction
- While all the instructions are strictly synchronized to the CPU clock, the interrupt line is generally not
- The interrupt line can change its status at any time and typically in the middle of an instruction, completely *ASYNCHRONOUSLY* to the instruction execution
- Interrupts are ASYNCHRONOUS to the executing program
- The CPU has a special "Interrupt Entry" instruction, which is often one of the longest in the instruction set
- For example, the ARM Cortex-M "Interrupt Entry" takes at least 12 cycles, whereas other simpler instructions such as MOV or ADD, can execute in just 1 clock cycle
- Toggle a bit, use XOR-Equals Operator (^=)
- All CPUs have a way to block the interrupt line in software
- ARM Cortex-M CPUs have a special bit called "PRIMASK" that must be cleared in software for interrupts to reach the CPU

## L17 -> Interrupts Part-2: How most CPUs (eg. MSP430) handle interrupts?

- BL: Branch-with-link instruction
- No other processor except ARM Cortex-M, allows interrupt handlers to be regular C functions
- Interrupt handler, also called Interrupt Service Routine (ISR)
- A single step in the IAR workbench disables checking for interrupts after each instruction
- SR: Status Register
- An ISR can differ from a regular C function in one more important way,\
  - An ISR must save more CPU registers than a regular function

- A function call from within an ISR can clobber (overwriting contents) registers, so they have to be preserved\
  -  Otherwise, the interrupt preemption would have a side effect of clobbering registers\
  -  An interrupt can preempt asynchronously any two instructions, so the compiler cannot tolerate clobbering registers\
  -  In contrast, a regular function call is synchronous, because the compiler is doing it via the CALL instruction or sometimes the BR instruction\
  -  In any case, the compiler is prepared that certain CPU registers will be potentially clobbered at this particular point in the code

## L18 -> Interrupts Part-3: How interrupts work on ARM Cortex-M?:

- Interrupts differ from regular functions in two important ways,\
  a. Interrupts return with a different machine instruction (reti instruction) than regular function instruction (ret instruction). These instructions must be different because they pop different registers from the stack\
  b. Interrupts must save more registers than a regular function

- In ARM Cortex-M, within the SysTick hardware peripheral, the "STCURRENT" register is write-clear\
  - Write-clear registers means writing to it with any value clear the register without triggering an interrupt

- ARM Cortex-M offers a direct way, which is to manually set the interrupt pending bit in the Interrupt Control and State Register (INTCTRL)
- Cortex-M provided an interrupt pending bit for every interrupt source, so you can trigger in the system by this method
- Most of these pending bits reside inside the Nested Vector Interrupt Controller (NVIC)

- FPU (Floating Point Unit): is a complex peripheral for speeding up floating-point computation\
  - But it adds complication to the interrupt processing

-  Stack grows down on ARM
-  Return address found in PC register
-  AAPCS: was a convention that specified, among others, which registers must be preserved by a function call
-  Cortex-M interrupt entry complements the ARM Procedure Call Standard (AAPCS)\
  - So, that's why a regular C function can be used as an interrupt handler\
  - This elevates the AAPCS from merely a calling convention that in principle could be different for each compiler, to a hard rule that must be implemented the same way by all compilers
  
- 0xFFFFFFF9, which is negative 7 in 2s Complement\
  - This is not a valid address in the code space\
  - When this special value is loaded into the PC, the Cortex-M hardware treats this as a return from an interrupt

- A standard return from a function works also as a special return from an interrupt because the LR is loaded with a special value upon the interrupt entry
- Other processors return from interrupt by special instruction, whereas ARM Cortex-M returns by using special data content of the LR register (Flexible and Extensible)

- ARM provides several variants of interrupt returns,
  - Handler Mode: is the distinct processor state when it handles an exception, such as an interrupt or a fault
  - Thread Mode: is when it executes regular code, such as while(1) loop inside your main function
  - Floating-point State: Means here that FPU is activated and that interrupt uses the FPU stack frame as opposed to the regular stack frame
  - MSP: Main Stack Pointer
  - PSP: Process Stack Pointer

- ARM CPU has two stack pointers,\
  - SP-main
  - SP-process
  - But only one of them is visible as SP depending on the internal state of the CPU
  - This concept is called register banking and is another of the "ARM-special"

- In practice, stack misalignment should never happen, this is because the 8-byte stack alignment is a requirement of the AAPCS and compilers make sure that the stack is always aligned
- LR=0xFFFFFFE9, is the special FPU-type interrupt return utilizing the much bigger FPU stack frame,\
  - The moral is that you need to size the stack significantly bigger if you use the FPU
  - There is also an additional price to pay for longer interrupt entry and exit time


## L19 -> GNU-ARM Toolchain and Eclipse IDE:

- Stack grows toward the lower addresses on ARM, so a stack overflow could damage the RAM section above it
- This lesson discusses portability from IAR to GNU CCS

## L20 ->  Race Conditions: What are they and how to avoid them:

- A GPIO bit is set or cleared by the read-modify-write sequence of operations

- Race Condition: It occurs when two or more pieces of code that can preempt each other access a shared resource so that the result depends on the sequence of execution of these pieces of code.
- Two main strategies for eliminating the race condition,
  - First, mutual exclusion means that you ensure that only one piece of concurrent code can execute while accessing a resource.
  - 
(Note ends here)

## L21 -> Foreground-Background Architecture ("Superloop")

- When a variable is "volatile", you are telling the compiler that the variable might change unexpectedly even though no currently performed program instructions change it, which is exactly what can happen when a variable is modified in an interrupt.
- Foreground/Background architecture also known as "main+ISRs", which is very common in smaller embedded systems,
  -  Arduino is based on Foreground/Background architecture
  -  Also, consumer electronics and home appliances use this architecture
- for-loop with empty control [for (;;)] is equivalent to the while(1) loop and is a C language idiom that means for-ever
- Sequential-code (blocking) -> Event-driven code (non-blocking)

## L22 -> RTOS Part-1: What is a Real-Time Operating System?

- Discussion will only be on the Real-Time Kernel component of RTOS, which is responsible for multitasking
- RTOS is a sequential architecture
- RTOS Kernel -> Software that extent the basic foreground/background architecture by allowing you to run multiple background loops (Called Thread or Tasks) on a single CPU
- Multithreading (Multitasking) -> Switching the CPU context frequently from one Thread to another to create an illusion that each such Thread has the whole CPU all to itself
- The ARM CPU requires that the ISR stack frame be aligned at the 8-byte boundary
- The ARM CPU uses a "full stack", which means that the stack pointer points to the last used stack entry as opposed to the first free entry


## L23 -> RTOS Part-2: Automating the context switch:

- In standard RTOS implementation, the data structure associated with a thread is traditionally called a Thread Control Block (TCB)
- Thread creat/Thread start: A function to fabricate the register context on each thread's stack.
- On ARM Cortex-M the stack grows from high to low memory
- Higher priority numbers mean lower priority for preemption
- ARM Cortex-M cores implement interrupt priority only in the highest order bits of the priority byte

- Critical Section (Where ISR is disabled)

```c
__disable_irq()
//code
__enable_irq()
```
- CPSID: Machine instruction for disable interrupt
- CPSIE: Machine instruction to enable interrupt
- Tail-chaining: Typically an interrupt-exit involves popping the 8 registers from the stack, and an interrupt-entry typically involve pushing 8 registers on the stack.
  - But in this case of back to back interrupt processing, the ARM Cortex-M core skips the popping and pushing registers in the hardware optimization called "tail-chaining"

- Disassembly

0x000005C8  B672  CPSID  I \
0x000005CC  6809  LDR  r1,[r1, #0x00]

Here,\
0x000005CC     - Address in the code memory (in hex)\
6809           - Machine instruction opcode (in hex)\
LDR            - Human Readable Mnemonic of the instruction\
r1,[r1, #0x00] - Parameters

## L24 -> RTOS Part-3: Automating the scheduling with round-robin policy:

- Refactoring: When you don't want to change the behavior of the code, it already behaves according to your requirement, instead, you want to improve the internal design

- Composability: The addition of a new thread is confined to the main file and does not require changing any of the existing threads or the RTOS code

  - Thread becomes composable only after adding RTOS because without it you could not easily combine them to run seemingly, simultaneously, and independently from each other
 
- Context switch can only happen immediately after an interrupt because the whole stack layout assumes that the thread is switched as a return from an exception

- Every MHz in clock frequency corresponds to one clock tick per microsecond

- RTOS overhead: This is the ratio of CPU time spent inside the RTOS for things like scheduling or context switching to the total CPU time

## L25 -> RTOS Part-4: Efficient blocking of thread:

- Idle thread: A special thread, which the scheduler can run when no other threads are ready. This situation in the system is called the "idle" condition and therefore the special thread is called the "idle" thread

- The idle thread is the ideal place to apply low-power sleep mode

## L26 -> RTOS Part-5: What is "real-time"? Preemptive, priority-based scheduling:

- Important decision while working with the priority scheduler
  - How to assign priorities to your threads
  - Rule: Assign higher priorities to thread with shorter periods, which means also shorter deadlines
 
- RMA/RMS - Rate Monotonic scheduler
  1. Always assign thread priorities monotonically, meaning that threads with higher rates must run at higher priorities than threads with lower rates
  2. You need to know the CPU utilization of each thread, which you calculate as,

     Cn/Tn, where, Cn: Measured execution time, Tn: Period
  3. You need to calculate the total CPU utilization as the sum of all individual CPU utilization factors. If this total utilization is below the theoretical bound, all threads in the set are guaranteed to meet their deadlines
 
  C1/T1 + ... + Cn/Tn <= U(n) = n(2^(1/n) - 1)\

  Where,\
  C1/T1 + ... + Cn/Tn: Total utilization factor\
  U(n)               : Utilization bound\
  n                  : Number of threads

- For large number of threads U(n) approaches natural logarithm of 2,\

  lim(n->inf) n(2^(1/n) - 1) = ln(2) = 0.6931

  - So, if you stay below 70% of the CPU utilization, your set of threads will be schedulable, meaning they will all meet their deadlines

## L27 -> RTOS Part-6: Synchronization and communication among concurrent threads:

- Porting: The process of moving an application from one RTOS to another is called porting an application

- Interrupt Latency: The interrupt requests are ASYNCHRONOUS, meaning that in general they are not correlated with the execution of the code. Also, the CPU can recognize an interrupt only at the instruction boundaries, after which the CPU still needs to perform an interrupt entry
  - All these take some time, this time delay from the interrupt request to the first instruction of the interrupt service routine (ISR) is called the interrupt latency

- Maximum Interrupt Latency = Longest Critical Section + the Interrupt Entry Time

- Critical Section: A segment of code that must be executed atomically, meaning without interruption to prevent race condition
  - During the execution of a critical section, the current task holds exclusive access to shared resources or data, ensuring data consistency and preventing concurrent access by other tasks
 
  - This is typically managed by disabling interrupts or using synchronization mechanisms like mutexes or semaphores
 
  - Kernel Unaware Interrupt (Zero-interrupt latency): An interrupt handled by an ISR without RTOS kernels knowledge meaning the Kernel can't manage or schedule tasks based on it
 
  - Kernel: The core part of an operating system that manages system resources, handles system calls, and coordinates hardware and software interactions
 
  - Disable Selective Interrupts:
  - Can be done on: ARM Cortex-M3, M4, M7
  - But not on    : ARM Cortex-M0 or M0+

- Cortex-M3 and higher provides "BASEPRI" register, which allows to mask interrupts selectively only up to the specified interrupt priority level

- Semaphores: A synchronization tool used to control access to shared resources by multiple tasks, preventing race conditions and ensuring proper resource management

  - Binary semaphore: A semaphore with only two states, 0 and 1, used to manage access to a single shared resource, effectively acting as a lock
 
- Pull-up resistor enabled: Means that the pin will be normally at the high level while pressing the SW1 switch (in context with Tiva C series) will bring it down to the low level
 
- Debouncing: A technique used to eliminate false or noisy signals in digital input devices, like switches, or buttons, ensuring only a single, clean signal is registered from a press or release
 
## L28 -> RTOS Part-7: Mutual Exclusion Mechanism:

- Mutual Exclusion: Mutually exclusive access to shared resources
  - Critical section
  - Semaphore
  - Scheduler lock
  - Mutex
 
- "Static" variable: A variable that retains its value across multiple function calls and is limited to the function or file where it is declared

- Unbound priority inversion: This occurs when a high-priority task is blocked indefinitely because a lower-priority task holds a resource and intermediate-priority tasks preempt the lower-priority task, preventing it from releasing the resource

- The classic semaphore, while still applicable to synchronizing threads, is NOT a good mechanism for mutual exclusion in priority-based systems

- Selective scheduler locking is a NON-BLOCKING mutual exclusion mechanism, similar to the critical section was non-blocking

- Selective scheduler locking: Temporarily disable task switching for critical sections of code, ensuring that specific task run without interruption,
  - Which prevents unbounded priority inversion
  - The only limitation is that the thread can not block while holding the lock
  - Blocking while accessing a shared resource such as calling the blocking delay or the semaphores with APIs, is considered bad practice and should be avoided
 
- Mutex: Short for mutual exclusion is a synchronization mechanism used to control access to a shared resource in concurrent programming. It allows only one task or thread to access the resource at a time, preventing race conditions and ensuring data integrity

  - It is an RTOS object specifically designed for protecting resources shared among concurrent threads in the most generic case, where threads might block while accessing the shared resource

- Priority ceiling protocol is the preferred strategy

- Semaphore vs Mutex

Feature                     --- Semaphore                             --- Muutex\

Purpose                     --- Signaling or managing resource access --- Mutual Exclusion\
Ownership                   --- No ownership                          --- Has ownership\
Type                        --- Counting or binary                    --- Always binary
Priority Inversion Handling --- Typically does not handle             --- Often has priority inheritance
Usage                       --- Can signal/release by any task        --- Must be unlocked by the locking task

## L29 -> OOP Part-1 Encapsulation (Classes) in C and C++

- OOP is not the use of any specific language but rather a way of software design based on the 3 fundamental concepts:
  1. Encapsulation  : The ability to package data and function together into classes
  2. Inheritance    : The ability to define new classes based on existing classes in order to obtain reuse and code organization
  3. Polymorphism   : The ability to substitute objects of matching for one another at run-time
 
- Class: A "class" combines both data, which are called in OOP *attributes* and functions, which are called in OOP *operations* into one entity the CLASS.
  - Object == Instance of a class

- Interfaces should be "easy" to use correctly and "hard" to use incorrectly
- malloc(): Used to dynamically allocate a block of memory on the heap
  - It stands for memory allocation
  - Return a pointer to the beginning of the allocated memory block

- Heap: A region of a computer memory used for dynamic memory allocation
  - Allows programs to allocate & deallocate memory at runtime
  - malloc() or free() in C

- Encapsulation does NOT prevent concurrency hazards

## L30 -> OOP Part 2 -> Inheritance in C and C++

- Encapsulation means you organize your code into *classes* that package data and function together

- Inheritance: This is the ability to define new classes based on existing classes in order to reuse the code and organization

- Upcasting: Converting a derived class object to a base class object in OOP

## L31 -> OOP Part 3 -> Polymorphism in C++:

- Polymorphism: The ability to substitute objects of matching interfaces for one another at run-time
  - In practice, among other things, polymorphism allows you to write generic code at a higher level of abstraction than you could without it
  - The connection between the function call and the function body is called "call binding"
  - The connection established at compile and link time is called "early binding"

## L32 -> OOP Part 4 -> Polymorphism in C:

- Polymorphism: The ability to provide different methods for the same inherited operation in the subclasses of a given class
- Guideline for using polymorphism
  - Type-specific behavior needed at runtime
    - Use polymorphism
  - Type-specific behavior NOT needed at runtime
    - Don't use polymorphism 

## L33 -> Event-Driven Programming Part 1: GUI example, events, event-loop, run-to-completion, no-blocking:

- API: Application Programming Interface
- 


## L34 -> 


## L35 -> 


## L36 -> 


## L37 -> 


## L38 -> 



## L39 -> 



## L40 -> 


## L41 -> 


## L42 -> 


## L43 -> 



## L44 -> 



## L45 -> 



## L46 -> 



## L47 -> 



## L48 -> 



## L49 -> 



## L50 -> 



## L51 -> 















  























  
















